package main

import (
	"fmt"
	"log"
)

/*
К каким негативным последствиям может привести данный фрагмент кода, и как это исправить?
Приведите корректный пример реализации.


var justString string
func someFunc() {
	v := createHugeString(1 << 10)
	justString = v[:100]
}

func main() {
	someFunc()
}

Решение:
1) При получении слайса от строки v[:100](при условии что строка содержит меньше 100 байтов из которых состоит строка)
можем выйти за ее пределы и получить ошибку вида:
runtime error: slice bounds out of range [:100] with length

2) Так как функция создает очень большую строку, которая храниться в глобальной переменной, могут возникнут сложности с
очисткой кучи(в которой хранятся глобальные переменные) и даже не поместиться в памяти. И к тому же работа с переменной,
лежащей в куче по времени больше, чем с переменной на стэке

3) Такое изменение глобальной переменной может быть неожиданным для других функций,
которые к данной переменной обращаются

4) Так как функция createHugeString возвращает очень большую строку и запись всей этой строки в переменную v
избыточно(нам лишь нужно 100 байт), то достаточно присваивать первые 100 байти и возвращать эту переменную

5) случай, когда функция может возвращать строку меньше 100 байт, необходимо учесть, поэтому такую ошибку нужно
обработать с recover(), которая будет вызываться в завершении функции в случае наличии паники,
которую мы явно не вызываем, а возникает в особо сложном случае
Таким образом, с помощью recover() мы не остановим работу всей программы, а результатом будет пустая строка

Поэтому лучше возвращать из функции полученную строку



*/

func createHugeString(digit int) string {
	digit++
	return "43546356546456"
}

func someFunc() string {
	defer func() {
		if p := recover(); p != nil {
			log.Println(`Огромная строка меньше 100 байт: `, p)
		}
	}()
	return createHugeString(1 << 100)[:100]
}

func main() {
	str := someFunc()
	fmt.Println(str)
}
