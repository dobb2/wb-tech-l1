package main

import (
	"context"
	"fmt"
	"log"
	"os/signal"
	"syscall"
	"time"
)

/*
Реализовать постоянную запись данных в канал (главный поток).
Реализовать набор из N воркеров, которые читают произвольные данные из канала и выводят в stdout.
Необходима возможность выбора количества воркеров при старте.

Программа должна завершаться по нажатию Ctrl+C. Выбрать и обосновать способ завершения работы всех воркеров.


Решение:
Используем signal.NotifyContext для обработка отмены с помощью сигналов Unix(в задачи SIGINT) с использованием контекста.
Основной поток будет ожидать получение сигнала от контекста или записывать данные в канал по умолчанию.
При вызове ctrl+C поток получит сигнал от контекста и тогда главный поток закроет канал, из которого читают воркеры,
таким образом они прекратят чтение из канала.

Можно передавать контекст в горутины и таким образом уведомлять о завершении работы,
но горутины могут получить уведомление раньше главного потока, тем самым можно недополучить данные.
Корректнее, чтобы главный поток уведомлял горутины о их завершении с помощью закрытии канала.

При завершении горутин вызываем defer,
где выводится информация о их завершении(в реальной задаче могли бы завершать важные процессы или освобождать ресурсы)


Конструкция defer stop() гарантирует, что после выхода из функции или горутины контекст будёт отменён,
и таким образом вы избежите утекания горутины — явления, когда горутина продолжает выполняться и существовать в памяти,
но результат её работы больше никого не интересует.
*/

func main() {
	ch1 := make(chan string)
	var n int
	fmt.Scan(&n) // считываем число воркеров

	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT)
	defer log.Println("work is done")
	defer stop()

	for i := 0; i < n; i++ {
		numwork := i + 1
		go func(chan string, int) {
			defer log.Println("worker", numwork, "is done")
			for val := range ch1 {
				log.Println("worker", numwork, "get data:", val)
			}
		}(ch1, numwork)
	}

	for {
		select {
		case <-ctx.Done():
			close(ch1)
			log.Println("end write to chanel")
			return
		default:
			ch1 <- "abdbdb"
			time.Sleep(2 * time.Second)
		}
	}
}
